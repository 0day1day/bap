// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stdframe.piqi.proto

#ifndef PROTOBUF_stdframe_2epiqi_2eproto__INCLUDED
#define PROTOBUF_stdframe_2epiqi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_stdframe_2epiqi_2eproto();
void protobuf_AssignDesc_stdframe_2epiqi_2eproto();
void protobuf_ShutdownFile_stdframe_2epiqi_2eproto();

class std_frame;
class operand_list;
class operand_info;
class reg_operand;
class mem_operand;
class operand_usage;
class taint_info;

// ===================================================================

class std_frame : public ::google::protobuf::Message {
 public:
  std_frame();
  virtual ~std_frame();
  
  std_frame(const std_frame& from);
  
  inline std_frame& operator=(const std_frame& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const std_frame& default_instance();
  
  void Swap(std_frame* other);
  
  // implements Message ----------------------------------------------
  
  std_frame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const std_frame& from);
  void MergeFrom(const std_frame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline ::google::protobuf::uint64 address() const;
  inline void set_address(::google::protobuf::uint64 value);
  
  // required uint64 thread_id = 2;
  inline bool has_thread_id() const;
  inline void clear_thread_id();
  static const int kThreadIdFieldNumber = 2;
  inline ::google::protobuf::uint64 thread_id() const;
  inline void set_thread_id(::google::protobuf::uint64 value);
  
  // required bytes rawbytes = 3;
  inline bool has_rawbytes() const;
  inline void clear_rawbytes();
  static const int kRawbytesFieldNumber = 3;
  inline const ::std::string& rawbytes() const;
  inline void set_rawbytes(const ::std::string& value);
  inline void set_rawbytes(const char* value);
  inline void set_rawbytes(const void* value, size_t size);
  inline ::std::string* mutable_rawbytes();
  inline ::std::string* release_rawbytes();
  
  // required .operand_list operand_list = 4;
  inline bool has_operand_list() const;
  inline void clear_operand_list();
  static const int kOperandListFieldNumber = 4;
  inline const ::operand_list& operand_list() const;
  inline ::operand_list* mutable_operand_list();
  inline ::operand_list* release_operand_list();
  
  // @@protoc_insertion_point(class_scope:std_frame)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_thread_id();
  inline void clear_has_thread_id();
  inline void set_has_rawbytes();
  inline void clear_has_rawbytes();
  inline void set_has_operand_list();
  inline void clear_has_operand_list();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 address_;
  ::google::protobuf::uint64 thread_id_;
  ::std::string* rawbytes_;
  ::operand_list* operand_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_stdframe_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stdframe_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stdframe_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static std_frame* default_instance_;
};
// -------------------------------------------------------------------

class operand_list : public ::google::protobuf::Message {
 public:
  operand_list();
  virtual ~operand_list();
  
  operand_list(const operand_list& from);
  
  inline operand_list& operator=(const operand_list& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const operand_list& default_instance();
  
  void Swap(operand_list* other);
  
  // implements Message ----------------------------------------------
  
  operand_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const operand_list& from);
  void MergeFrom(const operand_list& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .operand_info elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::operand_info& elem(int index) const;
  inline ::operand_info* mutable_elem(int index);
  inline ::operand_info* add_elem();
  inline const ::google::protobuf::RepeatedPtrField< ::operand_info >&
      elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::operand_info >*
      mutable_elem();
  
  // @@protoc_insertion_point(class_scope:operand_list)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::operand_info > elem_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_stdframe_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stdframe_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stdframe_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static operand_list* default_instance_;
};
// -------------------------------------------------------------------

class operand_info : public ::google::protobuf::Message {
 public:
  operand_info();
  virtual ~operand_info();
  
  operand_info(const operand_info& from);
  
  inline operand_info& operator=(const operand_info& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const operand_info& default_instance();
  
  void Swap(operand_info* other);
  
  // implements Message ----------------------------------------------
  
  operand_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const operand_info& from);
  void MergeFrom(const operand_info& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .mem_operand mem_operand = 1;
  inline bool has_mem_operand() const;
  inline void clear_mem_operand();
  static const int kMemOperandFieldNumber = 1;
  inline const ::mem_operand& mem_operand() const;
  inline ::mem_operand* mutable_mem_operand();
  inline ::mem_operand* release_mem_operand();
  
  // optional .reg_operand reg_operand = 2;
  inline bool has_reg_operand() const;
  inline void clear_reg_operand();
  static const int kRegOperandFieldNumber = 2;
  inline const ::reg_operand& reg_operand() const;
  inline ::reg_operand* mutable_reg_operand();
  inline ::reg_operand* release_reg_operand();
  
  // @@protoc_insertion_point(class_scope:operand_info)
 private:
  inline void set_has_mem_operand();
  inline void clear_has_mem_operand();
  inline void set_has_reg_operand();
  inline void clear_has_reg_operand();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::mem_operand* mem_operand_;
  ::reg_operand* reg_operand_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_stdframe_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stdframe_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stdframe_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static operand_info* default_instance_;
};
// -------------------------------------------------------------------

class reg_operand : public ::google::protobuf::Message {
 public:
  reg_operand();
  virtual ~reg_operand();
  
  reg_operand(const reg_operand& from);
  
  inline reg_operand& operator=(const reg_operand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const reg_operand& default_instance();
  
  void Swap(reg_operand* other);
  
  // implements Message ----------------------------------------------
  
  reg_operand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reg_operand& from);
  void MergeFrom(const reg_operand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 bit_length = 1;
  inline bool has_bit_length() const;
  inline void clear_bit_length();
  static const int kBitLengthFieldNumber = 1;
  inline ::google::protobuf::int32 bit_length() const;
  inline void set_bit_length(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required .operand_usage operand_usage = 3;
  inline bool has_operand_usage() const;
  inline void clear_operand_usage();
  static const int kOperandUsageFieldNumber = 3;
  inline const ::operand_usage& operand_usage() const;
  inline ::operand_usage* mutable_operand_usage();
  inline ::operand_usage* release_operand_usage();
  
  // required .taint_info taint_info = 4;
  inline bool has_taint_info() const;
  inline void clear_taint_info();
  static const int kTaintInfoFieldNumber = 4;
  inline const ::taint_info& taint_info() const;
  inline ::taint_info* mutable_taint_info();
  inline ::taint_info* release_taint_info();
  
  // @@protoc_insertion_point(class_scope:reg_operand)
 private:
  inline void set_has_bit_length();
  inline void clear_has_bit_length();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_operand_usage();
  inline void clear_has_operand_usage();
  inline void set_has_taint_info();
  inline void clear_has_taint_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::operand_usage* operand_usage_;
  ::taint_info* taint_info_;
  ::google::protobuf::int32 bit_length_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_stdframe_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stdframe_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stdframe_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static reg_operand* default_instance_;
};
// -------------------------------------------------------------------

class mem_operand : public ::google::protobuf::Message {
 public:
  mem_operand();
  virtual ~mem_operand();
  
  mem_operand(const mem_operand& from);
  
  inline mem_operand& operator=(const mem_operand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mem_operand& default_instance();
  
  void Swap(mem_operand* other);
  
  // implements Message ----------------------------------------------
  
  mem_operand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mem_operand& from);
  void MergeFrom(const mem_operand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 bit_length = 1;
  inline bool has_bit_length() const;
  inline void clear_bit_length();
  static const int kBitLengthFieldNumber = 1;
  inline ::google::protobuf::int32 bit_length() const;
  inline void set_bit_length(::google::protobuf::int32 value);
  
  // required uint64 address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline ::google::protobuf::uint64 address() const;
  inline void set_address(::google::protobuf::uint64 value);
  
  // required .operand_usage operand_usage = 3;
  inline bool has_operand_usage() const;
  inline void clear_operand_usage();
  static const int kOperandUsageFieldNumber = 3;
  inline const ::operand_usage& operand_usage() const;
  inline ::operand_usage* mutable_operand_usage();
  inline ::operand_usage* release_operand_usage();
  
  // required .taint_info taint_info = 4;
  inline bool has_taint_info() const;
  inline void clear_taint_info();
  static const int kTaintInfoFieldNumber = 4;
  inline const ::taint_info& taint_info() const;
  inline ::taint_info* mutable_taint_info();
  inline ::taint_info* release_taint_info();
  
  // @@protoc_insertion_point(class_scope:mem_operand)
 private:
  inline void set_has_bit_length();
  inline void clear_has_bit_length();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_operand_usage();
  inline void clear_has_operand_usage();
  inline void set_has_taint_info();
  inline void clear_has_taint_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 address_;
  ::operand_usage* operand_usage_;
  ::taint_info* taint_info_;
  ::google::protobuf::int32 bit_length_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_stdframe_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stdframe_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stdframe_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static mem_operand* default_instance_;
};
// -------------------------------------------------------------------

class operand_usage : public ::google::protobuf::Message {
 public:
  operand_usage();
  virtual ~operand_usage();
  
  operand_usage(const operand_usage& from);
  
  inline operand_usage& operator=(const operand_usage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const operand_usage& default_instance();
  
  void Swap(operand_usage* other);
  
  // implements Message ----------------------------------------------
  
  operand_usage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const operand_usage& from);
  void MergeFrom(const operand_usage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool read = 1;
  inline bool has_read() const;
  inline void clear_read();
  static const int kReadFieldNumber = 1;
  inline bool read() const;
  inline void set_read(bool value);
  
  // required bool written = 2;
  inline bool has_written() const;
  inline void clear_written();
  static const int kWrittenFieldNumber = 2;
  inline bool written() const;
  inline void set_written(bool value);
  
  // required bool index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline bool index() const;
  inline void set_index(bool value);
  
  // required bool base = 4;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 4;
  inline bool base() const;
  inline void set_base(bool value);
  
  // @@protoc_insertion_point(class_scope:operand_usage)
 private:
  inline void set_has_read();
  inline void clear_has_read();
  inline void set_has_written();
  inline void clear_has_written();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_base();
  inline void clear_has_base();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool read_;
  bool written_;
  bool index_;
  bool base_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_stdframe_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stdframe_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stdframe_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static operand_usage* default_instance_;
};
// -------------------------------------------------------------------

class taint_info : public ::google::protobuf::Message {
 public:
  taint_info();
  virtual ~taint_info();
  
  taint_info(const taint_info& from);
  
  inline taint_info& operator=(const taint_info& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const taint_info& default_instance();
  
  void Swap(taint_info* other);
  
  // implements Message ----------------------------------------------
  
  taint_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const taint_info& from);
  void MergeFrom(const taint_info& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool no_taint = 1;
  inline bool has_no_taint() const;
  inline void clear_no_taint();
  static const int kNoTaintFieldNumber = 1;
  inline bool no_taint() const;
  inline void set_no_taint(bool value);
  
  // optional uint64 taint_id = 2;
  inline bool has_taint_id() const;
  inline void clear_taint_id();
  static const int kTaintIdFieldNumber = 2;
  inline ::google::protobuf::uint64 taint_id() const;
  inline void set_taint_id(::google::protobuf::uint64 value);
  
  // optional bool taint_multiple = 3;
  inline bool has_taint_multiple() const;
  inline void clear_taint_multiple();
  static const int kTaintMultipleFieldNumber = 3;
  inline bool taint_multiple() const;
  inline void set_taint_multiple(bool value);
  
  // @@protoc_insertion_point(class_scope:taint_info)
 private:
  inline void set_has_no_taint();
  inline void clear_has_no_taint();
  inline void set_has_taint_id();
  inline void clear_has_taint_id();
  inline void set_has_taint_multiple();
  inline void clear_has_taint_multiple();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 taint_id_;
  bool no_taint_;
  bool taint_multiple_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_stdframe_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stdframe_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stdframe_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static taint_info* default_instance_;
};
// ===================================================================


// ===================================================================

// std_frame

// required uint64 address = 1;
inline bool std_frame::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void std_frame::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void std_frame::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void std_frame::clear_address() {
  address_ = GOOGLE_ULONGLONG(0);
  clear_has_address();
}
inline ::google::protobuf::uint64 std_frame::address() const {
  return address_;
}
inline void std_frame::set_address(::google::protobuf::uint64 value) {
  set_has_address();
  address_ = value;
}

// required uint64 thread_id = 2;
inline bool std_frame::has_thread_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void std_frame::set_has_thread_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void std_frame::clear_has_thread_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void std_frame::clear_thread_id() {
  thread_id_ = GOOGLE_ULONGLONG(0);
  clear_has_thread_id();
}
inline ::google::protobuf::uint64 std_frame::thread_id() const {
  return thread_id_;
}
inline void std_frame::set_thread_id(::google::protobuf::uint64 value) {
  set_has_thread_id();
  thread_id_ = value;
}

// required bytes rawbytes = 3;
inline bool std_frame::has_rawbytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void std_frame::set_has_rawbytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void std_frame::clear_has_rawbytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void std_frame::clear_rawbytes() {
  if (rawbytes_ != &::google::protobuf::internal::kEmptyString) {
    rawbytes_->clear();
  }
  clear_has_rawbytes();
}
inline const ::std::string& std_frame::rawbytes() const {
  return *rawbytes_;
}
inline void std_frame::set_rawbytes(const ::std::string& value) {
  set_has_rawbytes();
  if (rawbytes_ == &::google::protobuf::internal::kEmptyString) {
    rawbytes_ = new ::std::string;
  }
  rawbytes_->assign(value);
}
inline void std_frame::set_rawbytes(const char* value) {
  set_has_rawbytes();
  if (rawbytes_ == &::google::protobuf::internal::kEmptyString) {
    rawbytes_ = new ::std::string;
  }
  rawbytes_->assign(value);
}
inline void std_frame::set_rawbytes(const void* value, size_t size) {
  set_has_rawbytes();
  if (rawbytes_ == &::google::protobuf::internal::kEmptyString) {
    rawbytes_ = new ::std::string;
  }
  rawbytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* std_frame::mutable_rawbytes() {
  set_has_rawbytes();
  if (rawbytes_ == &::google::protobuf::internal::kEmptyString) {
    rawbytes_ = new ::std::string;
  }
  return rawbytes_;
}
inline ::std::string* std_frame::release_rawbytes() {
  clear_has_rawbytes();
  if (rawbytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rawbytes_;
    rawbytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .operand_list operand_list = 4;
inline bool std_frame::has_operand_list() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void std_frame::set_has_operand_list() {
  _has_bits_[0] |= 0x00000008u;
}
inline void std_frame::clear_has_operand_list() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void std_frame::clear_operand_list() {
  if (operand_list_ != NULL) operand_list_->::operand_list::Clear();
  clear_has_operand_list();
}
inline const ::operand_list& std_frame::operand_list() const {
  return operand_list_ != NULL ? *operand_list_ : *default_instance_->operand_list_;
}
inline ::operand_list* std_frame::mutable_operand_list() {
  set_has_operand_list();
  if (operand_list_ == NULL) operand_list_ = new ::operand_list;
  return operand_list_;
}
inline ::operand_list* std_frame::release_operand_list() {
  clear_has_operand_list();
  ::operand_list* temp = operand_list_;
  operand_list_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// operand_list

// repeated .operand_info elem = 1;
inline int operand_list::elem_size() const {
  return elem_.size();
}
inline void operand_list::clear_elem() {
  elem_.Clear();
}
inline const ::operand_info& operand_list::elem(int index) const {
  return elem_.Get(index);
}
inline ::operand_info* operand_list::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::operand_info* operand_list::add_elem() {
  return elem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operand_info >&
operand_list::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::operand_info >*
operand_list::mutable_elem() {
  return &elem_;
}

// -------------------------------------------------------------------

// operand_info

// optional .mem_operand mem_operand = 1;
inline bool operand_info::has_mem_operand() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void operand_info::set_has_mem_operand() {
  _has_bits_[0] |= 0x00000001u;
}
inline void operand_info::clear_has_mem_operand() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void operand_info::clear_mem_operand() {
  if (mem_operand_ != NULL) mem_operand_->::mem_operand::Clear();
  clear_has_mem_operand();
}
inline const ::mem_operand& operand_info::mem_operand() const {
  return mem_operand_ != NULL ? *mem_operand_ : *default_instance_->mem_operand_;
}
inline ::mem_operand* operand_info::mutable_mem_operand() {
  set_has_mem_operand();
  if (mem_operand_ == NULL) mem_operand_ = new ::mem_operand;
  return mem_operand_;
}
inline ::mem_operand* operand_info::release_mem_operand() {
  clear_has_mem_operand();
  ::mem_operand* temp = mem_operand_;
  mem_operand_ = NULL;
  return temp;
}

// optional .reg_operand reg_operand = 2;
inline bool operand_info::has_reg_operand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void operand_info::set_has_reg_operand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void operand_info::clear_has_reg_operand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void operand_info::clear_reg_operand() {
  if (reg_operand_ != NULL) reg_operand_->::reg_operand::Clear();
  clear_has_reg_operand();
}
inline const ::reg_operand& operand_info::reg_operand() const {
  return reg_operand_ != NULL ? *reg_operand_ : *default_instance_->reg_operand_;
}
inline ::reg_operand* operand_info::mutable_reg_operand() {
  set_has_reg_operand();
  if (reg_operand_ == NULL) reg_operand_ = new ::reg_operand;
  return reg_operand_;
}
inline ::reg_operand* operand_info::release_reg_operand() {
  clear_has_reg_operand();
  ::reg_operand* temp = reg_operand_;
  reg_operand_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// reg_operand

// required sint32 bit_length = 1;
inline bool reg_operand::has_bit_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void reg_operand::set_has_bit_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void reg_operand::clear_has_bit_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void reg_operand::clear_bit_length() {
  bit_length_ = 0;
  clear_has_bit_length();
}
inline ::google::protobuf::int32 reg_operand::bit_length() const {
  return bit_length_;
}
inline void reg_operand::set_bit_length(::google::protobuf::int32 value) {
  set_has_bit_length();
  bit_length_ = value;
}

// required string name = 2;
inline bool reg_operand::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void reg_operand::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void reg_operand::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void reg_operand::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& reg_operand::name() const {
  return *name_;
}
inline void reg_operand::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void reg_operand::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void reg_operand::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* reg_operand::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* reg_operand::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .operand_usage operand_usage = 3;
inline bool reg_operand::has_operand_usage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void reg_operand::set_has_operand_usage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void reg_operand::clear_has_operand_usage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void reg_operand::clear_operand_usage() {
  if (operand_usage_ != NULL) operand_usage_->::operand_usage::Clear();
  clear_has_operand_usage();
}
inline const ::operand_usage& reg_operand::operand_usage() const {
  return operand_usage_ != NULL ? *operand_usage_ : *default_instance_->operand_usage_;
}
inline ::operand_usage* reg_operand::mutable_operand_usage() {
  set_has_operand_usage();
  if (operand_usage_ == NULL) operand_usage_ = new ::operand_usage;
  return operand_usage_;
}
inline ::operand_usage* reg_operand::release_operand_usage() {
  clear_has_operand_usage();
  ::operand_usage* temp = operand_usage_;
  operand_usage_ = NULL;
  return temp;
}

// required .taint_info taint_info = 4;
inline bool reg_operand::has_taint_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void reg_operand::set_has_taint_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void reg_operand::clear_has_taint_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void reg_operand::clear_taint_info() {
  if (taint_info_ != NULL) taint_info_->::taint_info::Clear();
  clear_has_taint_info();
}
inline const ::taint_info& reg_operand::taint_info() const {
  return taint_info_ != NULL ? *taint_info_ : *default_instance_->taint_info_;
}
inline ::taint_info* reg_operand::mutable_taint_info() {
  set_has_taint_info();
  if (taint_info_ == NULL) taint_info_ = new ::taint_info;
  return taint_info_;
}
inline ::taint_info* reg_operand::release_taint_info() {
  clear_has_taint_info();
  ::taint_info* temp = taint_info_;
  taint_info_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// mem_operand

// required sint32 bit_length = 1;
inline bool mem_operand::has_bit_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mem_operand::set_has_bit_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mem_operand::clear_has_bit_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mem_operand::clear_bit_length() {
  bit_length_ = 0;
  clear_has_bit_length();
}
inline ::google::protobuf::int32 mem_operand::bit_length() const {
  return bit_length_;
}
inline void mem_operand::set_bit_length(::google::protobuf::int32 value) {
  set_has_bit_length();
  bit_length_ = value;
}

// required uint64 address = 2;
inline bool mem_operand::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mem_operand::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mem_operand::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mem_operand::clear_address() {
  address_ = GOOGLE_ULONGLONG(0);
  clear_has_address();
}
inline ::google::protobuf::uint64 mem_operand::address() const {
  return address_;
}
inline void mem_operand::set_address(::google::protobuf::uint64 value) {
  set_has_address();
  address_ = value;
}

// required .operand_usage operand_usage = 3;
inline bool mem_operand::has_operand_usage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mem_operand::set_has_operand_usage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mem_operand::clear_has_operand_usage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mem_operand::clear_operand_usage() {
  if (operand_usage_ != NULL) operand_usage_->::operand_usage::Clear();
  clear_has_operand_usage();
}
inline const ::operand_usage& mem_operand::operand_usage() const {
  return operand_usage_ != NULL ? *operand_usage_ : *default_instance_->operand_usage_;
}
inline ::operand_usage* mem_operand::mutable_operand_usage() {
  set_has_operand_usage();
  if (operand_usage_ == NULL) operand_usage_ = new ::operand_usage;
  return operand_usage_;
}
inline ::operand_usage* mem_operand::release_operand_usage() {
  clear_has_operand_usage();
  ::operand_usage* temp = operand_usage_;
  operand_usage_ = NULL;
  return temp;
}

// required .taint_info taint_info = 4;
inline bool mem_operand::has_taint_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mem_operand::set_has_taint_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mem_operand::clear_has_taint_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mem_operand::clear_taint_info() {
  if (taint_info_ != NULL) taint_info_->::taint_info::Clear();
  clear_has_taint_info();
}
inline const ::taint_info& mem_operand::taint_info() const {
  return taint_info_ != NULL ? *taint_info_ : *default_instance_->taint_info_;
}
inline ::taint_info* mem_operand::mutable_taint_info() {
  set_has_taint_info();
  if (taint_info_ == NULL) taint_info_ = new ::taint_info;
  return taint_info_;
}
inline ::taint_info* mem_operand::release_taint_info() {
  clear_has_taint_info();
  ::taint_info* temp = taint_info_;
  taint_info_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// operand_usage

// required bool read = 1;
inline bool operand_usage::has_read() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void operand_usage::set_has_read() {
  _has_bits_[0] |= 0x00000001u;
}
inline void operand_usage::clear_has_read() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void operand_usage::clear_read() {
  read_ = false;
  clear_has_read();
}
inline bool operand_usage::read() const {
  return read_;
}
inline void operand_usage::set_read(bool value) {
  set_has_read();
  read_ = value;
}

// required bool written = 2;
inline bool operand_usage::has_written() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void operand_usage::set_has_written() {
  _has_bits_[0] |= 0x00000002u;
}
inline void operand_usage::clear_has_written() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void operand_usage::clear_written() {
  written_ = false;
  clear_has_written();
}
inline bool operand_usage::written() const {
  return written_;
}
inline void operand_usage::set_written(bool value) {
  set_has_written();
  written_ = value;
}

// required bool index = 3;
inline bool operand_usage::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void operand_usage::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void operand_usage::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void operand_usage::clear_index() {
  index_ = false;
  clear_has_index();
}
inline bool operand_usage::index() const {
  return index_;
}
inline void operand_usage::set_index(bool value) {
  set_has_index();
  index_ = value;
}

// required bool base = 4;
inline bool operand_usage::has_base() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void operand_usage::set_has_base() {
  _has_bits_[0] |= 0x00000008u;
}
inline void operand_usage::clear_has_base() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void operand_usage::clear_base() {
  base_ = false;
  clear_has_base();
}
inline bool operand_usage::base() const {
  return base_;
}
inline void operand_usage::set_base(bool value) {
  set_has_base();
  base_ = value;
}

// -------------------------------------------------------------------

// taint_info

// optional bool no_taint = 1;
inline bool taint_info::has_no_taint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void taint_info::set_has_no_taint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void taint_info::clear_has_no_taint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void taint_info::clear_no_taint() {
  no_taint_ = false;
  clear_has_no_taint();
}
inline bool taint_info::no_taint() const {
  return no_taint_;
}
inline void taint_info::set_no_taint(bool value) {
  set_has_no_taint();
  no_taint_ = value;
}

// optional uint64 taint_id = 2;
inline bool taint_info::has_taint_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void taint_info::set_has_taint_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void taint_info::clear_has_taint_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void taint_info::clear_taint_id() {
  taint_id_ = GOOGLE_ULONGLONG(0);
  clear_has_taint_id();
}
inline ::google::protobuf::uint64 taint_info::taint_id() const {
  return taint_id_;
}
inline void taint_info::set_taint_id(::google::protobuf::uint64 value) {
  set_has_taint_id();
  taint_id_ = value;
}

// optional bool taint_multiple = 3;
inline bool taint_info::has_taint_multiple() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void taint_info::set_has_taint_multiple() {
  _has_bits_[0] |= 0x00000004u;
}
inline void taint_info::clear_has_taint_multiple() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void taint_info::clear_taint_multiple() {
  taint_multiple_ = false;
  clear_has_taint_multiple();
}
inline bool taint_info::taint_multiple() const {
  return taint_multiple_;
}
inline void taint_info::set_taint_multiple(bool value) {
  set_has_taint_multiple();
  taint_multiple_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_stdframe_2epiqi_2eproto__INCLUDED
