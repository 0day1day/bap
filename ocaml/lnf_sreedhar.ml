module D = Debug.Make(struct let name = "LnfHavlak" and default=`NoDebug end)
open D
open Lnf

module Make(C: G) =
struct
  (* Get loop information from Havlakcs loop forest *)
  let lnf cfg v0 =
    let module Comp = Graph.Components.Make(C) in
    let module VS = Set.Make(C.V) in
    let module Dom = Dominator.Make(C) in 
    let dom_funs = Dom.compute_all cfg v0 in 
    let sdom = dom_funs.Dom.sdom in 
    let find_headers scc =
      (*
       * The set of primary loops identified by the Sreedhar et al. algorithm
       * can be shown to be the same as the loop nesting forest generated by
       * the scheme of Section 4.2 when we define H(X) to be the set of
       * vertices in X that are not strictly dominated by any vertex in X.
       *)
      let is_header x = not (List.exists (fun v -> sdom v x) scc) in 
      List.filter is_header scc in 

    let f cfg =
      (*
       * We only want to process loops. The scc algorithm will identify
       * isolated nodes, but we only consider those that also have a self loop.
       *)
      let sccs = List.filter (fun scc ->
        match scc with
        | [x] -> C.mem_edge cfg x x
        | _ -> true) (Comp.scc_list cfg) in
      let rec process_scc cfg scc =
        dprintf "process_scc";
        match scc with
        | [] -> failwith "loopinfo_from_havlak: impossible"
        | [x] -> dprintf "Self loop at %s" (C.v2s x);
          { headers=scc; body=scc; children=[] }
        | _ ->
          let h = Hashtbl.create (List.length scc) in
          List.iter (fun v -> dprintf "scc %s" (C.v2s v); Hashtbl.add h v ()) scc;
          let cfg = cfg in

          let entry_nodes = List.fold_right VS.add (find_headers scc) VS.empty in

          let closing_edges = C.fold_edges_e (fun e l ->
            if Hashtbl.mem h (C.E.src e) = true && VS.mem (C.E.dst e) entry_nodes = true
            then e::l
            else l
          ) cfg [] in

          dprintf "entry nodes %d closing edges %d" (VS.cardinal entry_nodes) (List.length closing_edges);

          (* Progress check *)
          assert (closing_edges <> []);

          (* Remove closing edges *)
          let cfg = List.iter (C.remove_edge_e cfg) closing_edges; cfg in

          (* SCCs contained in original region *)
          let sccs = List.filter (fun scc ->
            List.for_all (Hashtbl.mem h) scc && match scc with
                                                | [x] -> C.mem_edge cfg x x
                                                | _ -> true
          ) (Comp.scc_list cfg) in

          { headers=List.sort compare (VS.elements entry_nodes)
          ; body=List.sort compare scc
          ; children=List.sort compare (List.map (process_scc cfg) sccs) }

      in
      match sccs with
      | [] -> failwith "loopinfo_from_havlak: impossible"
      | _ -> List.sort compare (List.map (process_scc cfg) sccs)
    in
    f cfg
end
