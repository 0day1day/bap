\section{Generating and Working with IL}

One of BAP's central features is the ability to represent the
semantics of binary code in a simple language called BIL (BAP
Intermediate Language).  This example demonstrates how to lift binary
code to the IL and manipulate it in BAP.  Let's start with the
following assembly file:

\lstinputlisting[basicstyle=\ttfamily,numbers=left]{chap-examples/basic.S}

\subsection{Lifting to the IL}

In this form, the program looks very simple.  Let's see what the BAP
representation of the program shows us.  Compile this file (basic.S)
to an object file with \cmdline{gcc -c basic.S -o basic.o}.  We can
lift this object file with BAP's \cmdline{toil} command: \cmdline{toil
  -bin basic.o -o basic.il}. If you inspect \cmdline{basic.il}, you
should see something like:

\verbatiminput{chap-examples/basic.il}

You can see from this example that BAP IL is much more verbose than
assembly; this is intentional.  It might make BAP IL a little more
tedious to read, but it makes writing analyses much simpler.  Let's go
through some of the IL line by line to explain what is happening.

\begin{verbatim}
addr 0x0 @asm "add    %eax,%ebx"
label pc_0x0
\end{verbatim}
These two statements mark the beginning of a new assembly instruction.
Note the label for pc\_0x0; any jump to address zero will go to to
this label.

\begin{verbatim}
T_t1:u32 = R_EBX_32:u32
\end{verbatim}
Here we are saving the original value of \%ebx before it is modified.
This original value will be used when computing flags.

\begin{verbatim}
T_t2:u32 = R_EAX_32:u32
\end{verbatim}
Here we are saving the original value of \%eax.  \%eax is not modified
in this struction, but a temporary is used to avoid duplicating the
operand in the IL.  Dupliation is a more serious problem for memory
operands.

\begin{verbatim}
R_EBX_32:u32 = R_EBX_32:u32 + T_t2:u32
\end{verbatim}
This is the primary computation of the add instruction: adding \%eax
to \%ebx.

\begin{verbatim}
R_CF:bool = R_EBX_32:u32 < T_t1:u32
\end{verbatim}
Here we explicitly compute the value of the carry flag.  After
executing the add instruction, the carry flag is set if the resulting
value of \%ebx is less than the original value of \%ebx (which is
saved in t).

\begin{verbatim}
R_OF:bool =
  if T_origCOUNT:u32 == 0:u32 then R_OF:bool else
  if T_origCOUNT:u32 == 1:u32 then high:bool(R_EBX_32:u32)
    ^ R_CF:bool else
  unknown "OF undefined after shift":bool
\end{verbatim}
Here we are explicitly computing the overflow flag after the shl
instruction.  Note that the IL uses if then else expressions.  Also
note that the the overflow flag can be set to an unknown expression
when the Intel semantics says the flag should be undefined.

\begin{verbatim}
cjmp R_CF:bool, 8:u32, "nocjmp0"
\end{verbatim}
This is a conditional jump.  If the condition (in this case, the carry
flag) evalutes to true, control will transfer to label pc\_0x8.
Otherwise, it will go to the label nocjmp0.

\subsection{Built-in Graphs and Analyses}

We might want to visualize what's going on.  There are several ways to
do this in BAP, including control flow graphs (CFG), control
dependence graphs (CDG), and data dependence graphs (DDG).  These can
be generated with the iltrans tool.  iltrans takes a program as input,
and then applies transformations in a pipeline.  For instance, we can
print an overview control flow graph by coalescing and then printing
the graph with \cmdline{iltrans -il basic.il -to-cfg -prune-cfg
  -coalesce-ast -pp-ast-asms out.dot}. The resulting file out.dot is a
file that can be processed with GraphViz's dot command: \cmdline{dot
  -Tpdf out.dot -o out.pdf}.  The output should look similar to what
is shown in Figure~\ref{fig:basiccfg}. The next visualizations will
require the program to be in Single Static Assignment (SSA) form.  The
command
\begin{verbatim}
iltrans -il basic.il -to-ssa
\end{verbatim}
will do this.  If we want to print a detailed control flow graph from
SSA form, we can add \cmdline{-pp-ssa out.dot} to the end, for
instance: 
\begin{verbatim}
iltrans -il basic.il -to-ssa -pp-ssa out.dot
\end{verbatim}
The output should look similar to what is shown in
Figure~\ref{fig:ssacfg}. Alternatively, we can also convert out of SSA
form and print that CFG by appending \cmdline{-to-cfg -pp-ast-cfg
  out.dot} to the command line, such as in:
\begin{verbatim}
iltrans -il basic.il -to-ssa -to-cfg -pp-ast-cfg out.dot
\end{verbatim}
As can be seen in Figure~\ref{fig:ssaconvcfg}, sometimes CFGs that
have been converted out of SSA can be easier to read. The CDG and DDG
can be generated by using \cmdline{-pp-ssa-cdg} and
\cmdline{-pp-ssa-ddg} respectively. Examples are shown in
Figures~\ref{fig:cdg} and \ref{fig:ddg}.

BAP also has built-in optimizations.  To apply them, simply use the
\cmdline{-simp-ssa} iltrans flag.  If we apply this before producing
the CFG, we can see the IL is greatly simplified: \cmdline{iltrans -il
  basic.il -to-ssa -simp-ssa -to-cfg -pp-ast-cfg out.dot}. This is shown in
Figure~\ref{fig:cfgsimp}.

\begin{figure}[!p]
  \begin{center}
    \includegraphics[height=3in]{chap-examples/basiccfg.pdf}
  \end{center}
  \caption{Example Basic CFG}
  \label{fig:basiccfg}
\end{figure}

\begin{figure}[!p]
  \begin{center}
    \includegraphics[height=.9\textheight]{chap-examples/ssacfg.pdf}
  \end{center}
  \caption{Example Detailed SSA CFG}
  \label{fig:ssacfg}
\end{figure}

\begin{figure}[!p]
  \begin{center}
    \includegraphics[height=.9\textheight]{chap-examples/ssaconvcfg.pdf}
  \end{center}
  \caption{Example SSA CFG converted out of SSA}
  \label{fig:ssaconvcfg}
\end{figure}

\begin{figure}[p]
  \begin{center}
    \includegraphics{chap-examples/cdg.pdf}
  \end{center}
  \caption{Example CDG}
  \label{fig:cdg}
\end{figure}

\begin{figure}[p]
  \centerbox{
  \includegraphics[height=.9\textheight]{chap-examples/ddg.pdf}
}
  \caption{Example DDG}
  \label{fig:ddg}
\end{figure}

\begin{figure}[p]
  \begin{center}
    \includegraphics[height=.9\textheight]{chap-examples/ssasimpcfg.pdf}
  \end{center}
  \caption{Example Simplified CFG}
  \label{fig:cfgsimp}
\end{figure}
\FloatBarrier

\subsection{Verification Conditions}

Let's say we want to know if we can take the jump at address four.  We
can test this in BAP by using verification conditions (VCs).  To do
this, we need to add a helper variable to the IL that represents
success.  We can do this by setting the goal variable to \texttt{true}
at the beginning of the program, and setting it to false if the
desired branch is not taken.  Below is the modified IL that does this.

\begin{centering}
\begin{scriptsize}
\verbatiminput{chap-examples/basic_mod.il}
\end{scriptsize}
\end{centering}

To see if we take the jump, we can use topredicate with the post
condition \cmdline{goal}: \cmdline{topredicate -q -il basic\_mod.il
  -stp-out /tmp/f -post goal -solve}.  This will create a VC, and then
solve it using the \cmdline{stp} solver.  \cmdline{stp} returned
\begin{verbatim}
R_EAX_32_11 -> 20000000
R_EBX_32_13 -> 0
R_ECX_32_15 -> 3
\end{verbatim}
as a satisfying answer. Sure enough, $0x0 + 0x20000000 = 0x20000000$
and $0x20000000 << 0x3$ sets the carry flag, so the program would take
the jump.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../main"
%%% End: 
